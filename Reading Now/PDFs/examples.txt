# PDFs - Comprehensive Examples and Code Samples

## 1. PDF Reading and Text Extraction

### PyPDF2 - Basic PDF Reading
```python
import PyPDF2
import os

def read_pdf_text(pdf_path):
    """Extract text from PDF using PyPDF2"""
    try:
        with open(pdf_path, 'rb') as file:
            pdf_reader = PyPDF2.PdfReader(file)
            text = ""
            
            # Get number of pages
            num_pages = len(pdf_reader.pages)
            print(f"PDF has {num_pages} pages")
            
            # Extract text from each page
            for page_num in range(num_pages):
                page = pdf_reader.pages[page_num]
                text += page.extract_text()
                
            return text
    except Exception as e:
        print(f"Error reading PDF: {e}")
        return None

# Example usage
pdf_text = read_pdf_text("document.pdf")
if pdf_text:
    print(pdf_text[:500])  # Print first 500 characters
```

### pdfplumber - Advanced Text Extraction
```python
import pdfplumber
import pandas as pd

def extract_pdf_data(pdf_path):
    """Extract text, tables, and metadata using pdfplumber"""
    data = {
        'text': [],
        'tables': [],
        'metadata': {}
    }
    
    with pdfplumber.open(pdf_path) as pdf:
        # Get metadata
        data['metadata'] = {
            'pages': len(pdf.pages),
            'creator': pdf.metadata.get('Creator', 'Unknown'),
            'title': pdf.metadata.get('Title', 'Unknown')
        }
        
        for page_num, page in enumerate(pdf.pages):
            # Extract text
            page_text = page.extract_text()
            if page_text:
                data['text'].append({
                    'page': page_num + 1,
                    'text': page_text
                })
            
            # Extract tables
            tables = page.extract_tables()
            for table_num, table in enumerate(tables):
                df = pd.DataFrame(table[1:], columns=table[0])
                data['tables'].append({
                    'page': page_num + 1,
                    'table': table_num + 1,
                    'data': df
                })
    
    return data

# Example usage
pdf_data = extract_pdf_data("report.pdf")
print(f"Extracted {len(pdf_data['text'])} pages of text")
print(f"Found {len(pdf_data['tables'])} tables")
```

## 2. PDF Creation and Generation

### ReportLab - Creating PDFs from Scratch
```python
from reportlab.lib.pagesizes import letter, A4
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch
from reportlab.lib import colors
from datetime import datetime

def create_report_pdf(filename, data):
    """Create a professional PDF report"""
    doc = SimpleDocTemplate(filename, pagesize=letter)
    styles = getSampleStyleSheet()
    story = []
    
    # Title
    title_style = ParagraphStyle(
        'CustomTitle',
        parent=styles['Heading1'],
        fontSize=24,
        spaceAfter=30,
        alignment=1  # Center alignment
    )
    title = Paragraph("Monthly Sales Report", title_style)
    story.append(title)
    story.append(Spacer(1, 12))
    
    # Date
    date_text = f"Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
    date_para = Paragraph(date_text, styles['Normal'])
    story.append(date_para)
    story.append(Spacer(1, 12))
    
    # Summary table
    table_data = [
        ['Metric', 'Value'],
        ['Total Sales', f'${data["total_sales"]:,.2f}'],
        ['Units Sold', f'{data["units_sold"]:,}'],
        ['Average Order', f'${data["avg_order"]:,.2f}'],
        ['Top Product', data["top_product"]]
    ]
    
    table = Table(table_data, colWidths=[2*inch, 2*inch])
    table.setStyle(TableStyle([
        ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
        ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, 0), 14),
        ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
        ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
        ('GRID', (0, 0), (-1, -1), 1, colors.black)
    ]))
    
    story.append(table)
    story.append(Spacer(1, 12))
    
    # Build PDF
    doc.build(story)
    print(f"PDF report created: {filename}")

# Example usage
report_data = {
    "total_sales": 125000.50,
    "units_sold": 1250,
    "avg_order": 100.00,
    "top_product": "Widget Pro"
}
create_report_pdf("sales_report.pdf", report_data)
```

### WeasyPrint - HTML to PDF Conversion
```python
import weasyprint
from jinja2 import Template

def html_to_pdf(html_content, output_path, css_string=None):
    """Convert HTML to PDF with custom styling"""
    
    default_css = """
    @page {
        margin: 2cm;
        @bottom-center {
            content: "Page " counter(page) " of " counter(pages);
        }
    }
    body {
        font-family: Arial, sans-serif;
        line-height: 1.6;
        color: #333;
    }
    .header {
        background-color: #f0f0f0;
        padding: 20px;
        text-align: center;
        border-bottom: 2px solid #ccc;
    }
    .content {
        padding: 20px;
    }
    table {
        width: 100%;
        border-collapse: collapse;
        margin: 20px 0;
    }
    th, td {
        border: 1px solid #ddd;
        padding: 8px;
        text-align: left;
    }
    th {
        background-color: #f2f2f2;
    }
    """
    
    css = css_string or default_css
    
    # Create PDF
    html_doc = weasyprint.HTML(string=html_content)
    css_doc = weasyprint.CSS(string=css)
    html_doc.write_pdf(output_path, stylesheets=[css_doc])
    
    print(f"HTML converted to PDF: {output_path}")

# Example HTML template
html_template = """
<!DOCTYPE html>
<html>
<head>
    <title>Invoice</title>
</head>
<body>
    <div class="header">
        <h1>INVOICE #{{ invoice_number }}</h1>
        <p>Date: {{ date }}</p>
    </div>
    
    <div class="content">
        <h2>Bill To:</h2>
        <p>{{ customer_name }}<br>
        {{ customer_address }}</p>
        
        <table>
            <thead>
                <tr>
                    <th>Item</th>
                    <th>Quantity</th>
                    <th>Price</th>
                    <th>Total</th>
                </tr>
            </thead>
            <tbody>
                {% for item in items %}
                <tr>
                    <td>{{ item.description }}</td>
                    <td>{{ item.quantity }}</td>
                    <td>${{ "%.2f"|format(item.price) }}</td>
                    <td>${{ "%.2f"|format(item.total) }}</td>
                </tr>
                {% endfor %}
            </tbody>
        </table>
        
        <h3>Total: ${{ total }}</h3>
    </div>
</body>
</html>
"""

# Generate invoice
template = Template(html_template)
invoice_data = {
    'invoice_number': 'INV-001',
    'date': '2025-06-02',
    'customer_name': 'John Doe',
    'customer_address': '123 Main St, City, State',
    'items': [
        {'description': 'Widget A', 'quantity': 2, 'price': 25.00, 'total': 50.00},
        {'description': 'Widget B', 'quantity': 1, 'price': 75.00, 'total': 75.00}
    ],
    'total': 125.00
}

html_content = template.render(**invoice_data)
html_to_pdf(html_content, "invoice.pdf")
```

## 3. PDF Manipulation and Processing

### PyPDF2 - Merging and Splitting PDFs
```python
import PyPDF2
import os
from pathlib import Path

def merge_pdfs(pdf_list, output_path):
    """Merge multiple PDFs into one"""
    pdf_merger = PyPDF2.PdfMerger()
    
    try:
        for pdf_path in pdf_list:
            if os.path.exists(pdf_path):
                pdf_merger.append(pdf_path)
                print(f"Added: {pdf_path}")
            else:
                print(f"Warning: {pdf_path} not found")
        
        pdf_merger.write(output_path)
        pdf_merger.close()
        print(f"Merged PDF saved as: {output_path}")
        
    except Exception as e:
        print(f"Error merging PDFs: {e}")

def split_pdf(input_path, output_dir):
    """Split PDF into individual pages"""
    try:
        with open(input_path, 'rb') as file:
            pdf_reader = PyPDF2.PdfReader(file)
            
            # Create output directory
            Path(output_dir).mkdir(exist_ok=True)
            
            for page_num in range(len(pdf_reader.pages)):
                pdf_writer = PyPDF2.PdfWriter()
                pdf_writer.add_page(pdf_reader.pages[page_num])
                
                output_filename = f"{output_dir}/page_{page_num + 1:03d}.pdf"
                with open(output_filename, 'wb') as output_file:
                    pdf_writer.write(output_file)
                
                print(f"Created: {output_filename}")
                
    except Exception as e:
        print(f"Error splitting PDF: {e}")

def extract_pages(input_path, output_path, start_page, end_page):
    """Extract specific pages from PDF"""
    try:
        with open(input_path, 'rb') as file:
            pdf_reader = PyPDF2.PdfReader(file)
            pdf_writer = PyPDF2.PdfWriter()
            
            # Validate page numbers
            total_pages = len(pdf_reader.pages)
            start_page = max(1, start_page)
            end_page = min(total_pages, end_page)
            
            # Extract pages (convert to 0-based indexing)
            for page_num in range(start_page - 1, end_page):
                pdf_writer.add_page(pdf_reader.pages[page_num])
            
            with open(output_path, 'wb') as output_file:
                pdf_writer.write(output_file)
            
            print(f"Extracted pages {start_page}-{end_page} to: {output_path}")
            
    except Exception as e:
        print(f"Error extracting pages: {e}")

# Example usage
pdf_files = ["doc1.pdf", "doc2.pdf", "doc3.pdf"]
merge_pdfs(pdf_files, "merged_document.pdf")

split_pdf("large_document.pdf", "split_pages")
extract_pages("document.pdf", "pages_5_to_10.pdf", 5, 10)
```

### PDF Form Handling
```python
from PyPDF2 import PdfReader, PdfWriter
from reportlab.pdfgen import canvas
from reportlab.lib.pagesizes import letter
import io

def fill_pdf_form(template_path, output_path, form_data):
    """Fill PDF form fields with data"""
    try:
        reader = PdfReader(template_path)
        writer = PdfWriter()
        
        # Get form fields
        if "/AcroForm" in reader.trailer["/Root"]:
            reader.trailer["/Root"]["/AcroForm"].update({
                "/NeedAppearances": True
            })
        
        # Fill form fields
        for page_num in range(len(reader.pages)):
            page = reader.pages[page_num]
            
            if "/Annots" in page:
                for annotation in page["/Annots"]:
                    annotation_obj = annotation.get_object()
                    if annotation_obj.get("/Subtype") == "/Widget":
                        field_name = annotation_obj.get("/T")
                        if field_name and field_name in form_data:
                            annotation_obj.update({
                                "/V": form_data[field_name]
                            })
            
            writer.add_page(page)
        
        with open(output_path, 'wb') as output_file:
            writer.write(output_file)
        
        print(f"Form filled and saved as: {output_path}")
        
    except Exception as e:
        print(f"Error filling PDF form: {e}")

def create_fillable_form(output_path):
    """Create a simple fillable PDF form"""
    buffer = io.BytesIO()
    p = canvas.Canvas(buffer, pagesize=letter)
    
    # Add form fields manually (simplified approach)
    p.drawString(100, 750, "Name: ___________________________")
    p.drawString(100, 720, "Email: ___________________________")
    p.drawString(100, 690, "Phone: ___________________________")
    p.drawString(100, 660, "Address: ___________________________")
    
    p.showPage()
    p.save()
    
    # Save the PDF
    buffer.seek(0)
    with open(output_path, 'wb') as f:
        f.write(buffer.getvalue())
    
    print(f"Fillable form created: {output_path}")

# Example form data
form_data = {
    "Name": "John Doe",
    "Email": "john.doe@email.com",
    "Phone": "+1-555-123-4567",
    "Address": "123 Main St, City, State, ZIP"
}

create_fillable_form("application_form.pdf")
# fill_pdf_form("application_form.pdf", "filled_form.pdf", form_data)
```

## 4. PDF Security and Encryption

### Password Protection and Encryption
```python
import PyPDF2
from PyPDF2 import PdfWriter, PdfReader

def encrypt_pdf(input_path, output_path, user_password, owner_password=None):
    """Add password protection to PDF"""
    try:
        reader = PdfReader(input_path)
        writer = PdfWriter()
        
        # Copy all pages
        for page in reader.pages:
            writer.add_page(page)
        
        # Add password protection
        owner_pwd = owner_password or user_password
        writer.encrypt(
            user_password=user_password,
            owner_password=owner_pwd,
            use_128bit=True
        )
        
        with open(output_path, 'wb') as output_file:
            writer.write(output_file)
        
        print(f"Encrypted PDF saved as: {output_path}")
        
    except Exception as e:
        print(f"Error encrypting PDF: {e}")

def decrypt_pdf(input_path, output_path, password):
    """Remove password protection from PDF"""
    try:
        reader = PdfReader(input_path)
        
        # Check if PDF is encrypted
        if reader.is_encrypted:
            # Try to decrypt with password
            if reader.decrypt(password):
                print("PDF decrypted successfully")
                
                writer = PdfWriter()
                for page in reader.pages:
                    writer.add_page(page)
                
                with open(output_path, 'wb') as output_file:
                    writer.write(output_file)
                
                print(f"Decrypted PDF saved as: {output_path}")
            else:
                print("Incorrect password")
        else:
            print("PDF is not encrypted")
            
    except Exception as e:
        print(f"Error decrypting PDF: {e}")

def add_watermark(input_path, output_path, watermark_text):
    """Add text watermark to PDF"""
    try:
        from reportlab.pdfgen import canvas
        from reportlab.lib.pagesizes import letter
        import io
        
        # Create watermark
        packet = io.BytesIO()
        can = canvas.Canvas(packet, pagesize=letter)
        can.setFont("Helvetica", 50)
        can.setFillColorRGB(0.5, 0.5, 0.5, alpha=0.3)  # Semi-transparent gray
        can.rotate(45)  # Diagonal watermark
        can.drawString(200, 200, watermark_text)
        can.save()
        
        # Move to the beginning of the StringIO buffer
        packet.seek(0)
        watermark_pdf = PdfReader(packet)
        watermark_page = watermark_pdf.pages[0]
        
        # Read the existing PDF
        reader = PdfReader(input_path)
        writer = PdfWriter()
        
        # Add watermark to each page
        for page in reader.pages:
            page.merge_page(watermark_page)
            writer.add_page(page)
        
        with open(output_path, 'wb') as output_file:
            writer.write(output_file)
        
        print(f"Watermarked PDF saved as: {output_path}")
        
    except Exception as e:
        print(f"Error adding watermark: {e}")

# Example usage
encrypt_pdf("document.pdf", "protected_document.pdf", "user123", "owner456")
decrypt_pdf("protected_document.pdf", "unlocked_document.pdf", "user123")
add_watermark("document.pdf", "watermarked_document.pdf", "CONFIDENTIAL")
```

## 5. PDF Analysis and Metadata

### Extracting PDF Information
```python
import PyPDF2
from PyPDF2 import PdfReader
import os
from datetime import datetime

def analyze_pdf(pdf_path):
    """Comprehensive PDF analysis"""
    try:
        reader = PdfReader(pdf_path)
        
        # Basic information
        info = {
            'filename': os.path.basename(pdf_path),
            'file_size': os.path.getsize(pdf_path),
            'num_pages': len(reader.pages),
            'is_encrypted': reader.is_encrypted,
            'metadata': {}
        }
        
        # Extract metadata
        if reader.metadata:
            metadata = reader.metadata
            info['metadata'] = {
                'title': metadata.get('/Title', 'Unknown'),
                'author': metadata.get('/Author', 'Unknown'),
                'subject': metadata.get('/Subject', 'Unknown'),
                'creator': metadata.get('/Creator', 'Unknown'),
                'producer': metadata.get('/Producer', 'Unknown'),
                'creation_date': metadata.get('/CreationDate', 'Unknown'),
                'modification_date': metadata.get('/ModDate', 'Unknown')
            }
        
        # Analyze pages
        page_info = []
        total_text_length = 0
        
        for page_num, page in enumerate(reader.pages):
            page_data = {
                'page_number': page_num + 1,
                'rotation': page.get('/Rotate', 0),
                'media_box': page.mediabox,
            }
            
            # Extract text and count characters
            try:
                text = page.extract_text()
                page_data['text_length'] = len(text)
                page_data['has_text'] = len(text.strip()) > 0
                total_text_length += len(text)
            except:
                page_data['text_length'] = 0
                page_data['has_text'] = False
            
            page_info.append(page_data)
        
        info['total_text_length'] = total_text_length
        info['pages'] = page_info
        
        return info
        
    except Exception as e:
        print(f"Error analyzing PDF: {e}")
        return None

def print_pdf_analysis(pdf_path):
    """Print detailed PDF analysis"""
    analysis = analyze_pdf(pdf_path)
    
    if not analysis:
        return
    
    print("=" * 50)
    print(f"PDF ANALYSIS: {analysis['filename']}")
    print("=" * 50)
    
    print(f"File size: {analysis['file_size']:,} bytes")
    print(f"Number of pages: {analysis['num_pages']}")
    print(f"Encrypted: {'Yes' if analysis['is_encrypted'] else 'No'}")
    print(f"Total text length: {analysis['total_text_length']:,} characters")
    
    print("\nMetadata:")
    for key, value in analysis['metadata'].items():
        print(f"  {key.title()}: {value}")
    
    print(f"\nPage Details:")
    for page in analysis['pages']:
        print(f"  Page {page['page_number']}: "
              f"{page['text_length']} chars, "
              f"Text: {'Yes' if page['has_text'] else 'No'}, "
              f"Rotation: {page['rotation']}°")

def batch_analyze_pdfs(directory_path):
    """Analyze all PDFs in a directory"""
    pdf_files = [f for f in os.listdir(directory_path) if f.lower().endswith('.pdf')]
    
    print(f"Found {len(pdf_files)} PDF files in {directory_path}")
    
    results = []
    for pdf_file in pdf_files:
        pdf_path = os.path.join(directory_path, pdf_file)
        analysis = analyze_pdf(pdf_path)
        if analysis:
            results.append(analysis)
    
    # Summary statistics
    if results:
        total_pages = sum(r['num_pages'] for r in results)
        total_size = sum(r['file_size'] for r in results)
        encrypted_count = sum(1 for r in results if r['is_encrypted'])
        
        print(f"\nSUMMARY:")
        print(f"Total PDFs analyzed: {len(results)}")
        print(f"Total pages: {total_pages}")
        print(f"Total size: {total_size:,} bytes")
        print(f"Encrypted files: {encrypted_count}")
    
    return results

# Example usage
print_pdf_analysis("document.pdf")
# batch_results = batch_analyze_pdfs("/path/to/pdf/directory")
```

## 6. OCR and Image Processing

### Using Tesseract for OCR
```python
import pytesseract
from PIL import Image
import pdf2image
import cv2
import numpy as np

def pdf_to_text_ocr(pdf_path, output_path=None):
    """Convert PDF to text using OCR"""
    try:
        # Convert PDF to images
        images = pdf2image.convert_from_path(pdf_path, dpi=300)
        
        extracted_text = ""
        
        for page_num, image in enumerate(images):
            print(f"Processing page {page_num + 1}...")
            
            # Convert PIL Image to numpy array for OpenCV
            img_array = np.array(image)
            
            # Preprocessing for better OCR
            gray = cv2.cvtColor(img_array, cv2.COLOR_RGB2GRAY)
            
            # Apply thresholding to get better text recognition
            _, thresh = cv2.threshold(gray, 150, 255, cv2.THRESH_BINARY)
            
            # Use Tesseract to extract text
            page_text = pytesseract.image_to_string(thresh, lang='eng')
            
            extracted_text += f"\n--- Page {page_num + 1} ---\n"
            extracted_text += page_text
            extracted_text += "\n"
        
        # Save to file if output path provided
        if output_path:
            with open(output_path, 'w', encoding='utf-8') as f:
                f.write(extracted_text)
            print(f"OCR text saved to: {output_path}")
        
        return extracted_text
        
    except Exception as e:
        print(f"Error in OCR processing: {e}")
        return None

def improve_image_for_ocr(image):
    """Preprocess image for better OCR results"""
    # Convert to numpy array if PIL Image
    if hasattr(image, 'convert'):
        img_array = np.array(image.convert('RGB'))
    else:
        img_array = image
    
    # Convert to grayscale
    gray = cv2.cvtColor(img_array, cv2.COLOR_RGB2GRAY)
    
    # Remove noise
    denoised = cv2.medianBlur(gray, 3)
    
    # Apply threshold
    _, thresh = cv2.threshold(denoised, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
    
    # Morphological operations to clean up
    kernel = np.ones((1, 1), np.uint8)
    opening = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, kernel)
    
    return opening

def extract_text_with_confidence(pdf_path):
    """Extract text with confidence scores"""
    try:
        images = pdf2image.convert_from_path(pdf_path, dpi=300)
        
        results = []
        
        for page_num, image in enumerate(images):
            # Preprocess image
            processed_img = improve_image_for_ocr(image)
            
            # Get detailed OCR data
            ocr_data = pytesseract.image_to_data(
                processed_img, 
                output_type=pytesseract.Output.DICT
            )
            
            # Filter words with high confidence
            high_confidence_text = []
            for i, word in enumerate(ocr_data['text']):
                confidence = int(ocr_data['conf'][i])
                if confidence > 30 and word.strip():  # Only include words with >30% confidence
                    high_confidence_text.append(word)
            
            page_result = {
                'page': page_num + 1,
                'text': ' '.join(high_confidence_text),
                'word_count': len(high_confidence_text),
                'avg_confidence': np.mean([int(conf) for conf in ocr_data['conf'] if int(conf) > 0])
            }
            
            results.append(page_result)
            print(f"Page {page_num + 1}: {len(high_confidence_text)} words, "
                  f"avg confidence: {page_result['avg_confidence']:.1f}%")
        
        return results
        
    except Exception as e:
        print(f"Error in confidence-based OCR: {e}")
        return None

# Example usage
# text = pdf_to_text_ocr("scanned_document.pdf", "extracted_text.txt")
# confidence_results = extract_text_with_confidence("scanned_document.pdf")
```

## 7. Advanced PDF Processing

### PDF Content Analysis and Search
```python
import PyPDF2
import re
from collections import Counter
import matplotlib.pyplot as plt
from wordcloud import WordCloud

def search_pdf_content(pdf_path, search_terms, case_sensitive=False):
    """Search for specific terms in PDF content"""
    try:
        reader = PdfReader(pdf_path)
        results = []
        
        for page_num, page in enumerate(reader.pages):
            text = page.extract_text()
            
            if not case_sensitive:
                text_lower = text.lower()
                search_terms_lower = [term.lower() for term in search_terms]
            else:
                text_lower = text
                search_terms_lower = search_terms
            
            page_results = {
                'page': page_num + 1,
                'matches': {}
            }
            
            for i, term in enumerate(search_terms):
                search_term = search_terms_lower[i]
                matches = len(re.findall(search_term, text_lower))
                if matches > 0:
                    page_results['matches'][term] = matches
            
            if page_results['matches']:
                results.append(page_results)
        
        return results
        
    except Exception as e:
        print(f"Error searching PDF: {e}")
        return None

def extract_keywords(pdf_path, top_n=20):
    """Extract most common keywords from PDF"""
    try:
        reader = PdfReader(pdf_path)
        all_text = ""
        
        for page in reader.pages:
            all_text += page.extract_text()
        
        # Clean text and extract words
        words = re.findall(r'\b[a-zA-Z]{3,}\b', all_text.lower())
        
        # Remove common stop words
        stop_words = {
            'the', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 
            'with', 'by', 'from', 'up', 'about', 'into', 'through', 'during',
            'before', 'after', 'above', 'below', 'between', 'among', 'this',
            'that', 'these', 'those', 'are', 'was', 'were', 'been', 'have',
            'has', 'had', 'will', 'would', 'could', 'should', 'may', 'might'
        }
        
        filtered_words = [word for word in words if word not in stop_words]
        
        # Count word frequency
        word_freq = Counter(filtered_words)
        
        return word_freq.most_common(top_n)
        
    except Exception as e:
        print(f"Error extracting keywords: {e}")
        return None

def create_pdf_wordcloud(pdf_path, output_path="wordcloud.png"):
    """Create a word cloud from PDF content"""
    try:
        reader = PdfReader(pdf_path)
        all_text = ""
        
        for page in reader.pages:
            all_text += page.extract_text()
        
        # Create word cloud
        wordcloud = WordCloud(
            width=800, 
            height=400, 
            background_color='white',
            max_words=100
        ).generate(all_text)
        
        # Save word cloud
        plt.figure(figsize=(10, 5))
        plt.imshow(wordcloud, interpolation='bilinear')
        plt.axis('off')
        plt.title('PDF Content Word Cloud')
        plt.savefig(output_path, bbox_inches='tight', dpi=300)
        plt.close()
        
        print(f"Word cloud saved as: {output_path}")
        
    except Exception as e:
        print(f"Error creating word cloud: {e}")

def pdf_reading_statistics(pdf_path):
    """Calculate reading time and statistics"""
    try:
        reader = PdfReader(pdf_path)
        
        total_words = 0
        total_chars = 0
        pages_with_text = 0
        
        for page in reader.pages:
            text = page.extract_text()
            words = len(text.split())
            chars = len(text)
            
            total_words += words
            total_chars += chars
            
            if words > 0:
                pages_with_text += 1
        
        # Reading time calculations (average reading speed: 200-250 WPM)
        reading_time_fast = total_words / 250  # minutes for fast readers
        reading_time_avg = total_words / 225   # minutes for average readers
        reading_time_slow = total_words / 200  # minutes for slow readers
        
        stats = {
            'total_pages': len(reader.pages),
            'pages_with_text': pages_with_text,
            'total_words': total_words,
            'total_characters': total_chars,
            'avg_words_per_page': total_words / pages_with_text if pages_with_text > 0 else 0,
            'reading_time': {
                'fast_reader': f"{reading_time_fast:.1f} minutes",
                'average_reader': f"{reading_time_avg:.1f} minutes",
                'slow_reader': f"{reading_time_slow:.1f} minutes"
            }
        }
        
        return stats
        
    except Exception as e:
        print(f"Error calculating statistics: {e}")
        return None

# Example usage
search_results = search_pdf_content("document.pdf", ["python", "programming", "code"])
if search_results:
    for result in search_results:
        print(f"Page {result['page']}: {result['matches']}")

keywords = extract_keywords("document.pdf", 15)
if keywords:
    print("Top keywords:")
    for word, count in keywords:
        print(f"  {word}: {count}")

stats = pdf_reading_statistics("document.pdf")
if stats:
    print(f"Total words: {stats['total_words']:,}")
    print(f"Reading time (average): {stats['reading_time']['average_reader']}")

# create_pdf_wordcloud("document.pdf")
```

## 8. PDF Automation and Batch Processing

### Automated PDF Processing Pipeline
```python
import os
import shutil
from pathlib import Path
import PyPDF2
from datetime import datetime
import json

class PDFProcessor:
    """Comprehensive PDF processing automation"""
    
    def __init__(self, input_dir, output_dir):
        self.input_dir = Path(input_dir)
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(exist_ok=True)
        
        # Create subdirectories
        (self.output_dir / "processed").mkdir(exist_ok=True)
        (self.output_dir / "extracted_text").mkdir(exist_ok=True)
        (self.output_dir / "split_pages").mkdir(exist_ok=True)
        (self.output_dir / "reports").mkdir(exist_ok=True)
        
        self.processing_log = []
    
    def process_all_pdfs(self):
        """Process all PDFs in input directory"""
        pdf_files = list(self.input_dir.glob("*.pdf"))
        
        print(f"Found {len(pdf_files)} PDF files to process")
        
        for pdf_file in pdf_files:
            try:
                print(f"\nProcessing: {pdf_file.name}")
                self.process_single_pdf(pdf_file)
            except Exception as e:
                error_msg = f"Error processing {pdf_file.name}: {e}"
                print(error_msg)
                self.processing_log.append({
                    'file': pdf_file.name,
                    'status': 'error',
                    'message': str(e),
                    'timestamp': datetime.now().isoformat()
                })
        
        self.generate_processing_report()
    
    def process_single_pdf(self, pdf_path):
        """Process a single PDF file"""
        pdf_name = pdf_path.stem
        
        try:
            reader = PdfReader(pdf_path)
            
            # Extract basic info
            info = {
                'filename': pdf_path.name,
                'pages': len(reader.pages),
                'encrypted': reader.is_encrypted,
                'size_bytes': pdf_path.stat().st_size
            }
            
            # Extract text
            text_output = self.output_dir / "extracted_text" / f"{pdf_name}.txt"
            self.extract_all_text(reader, text_output)
            
            # Split into individual pages (if more than 1 page)
            if len(reader.pages) > 1:
                split_dir = self.output_dir / "split_pages" / pdf_name
                split_dir.mkdir(exist_ok=True)
                self.split_pdf_to_pages(reader, split_dir, pdf_name)
            
            # Create optimized copy
            optimized_path = self.output_dir / "processed" / f"{pdf_name}_optimized.pdf"
            self.optimize_pdf(pdf_path, optimized_path)
            
            # Log success
            info['status'] = 'success'
            info['timestamp'] = datetime.now().isoformat()
            self.processing_log.append(info)
            
            print(f"  ✓ Completed processing {pdf_path.name}")
            
        except Exception as e:
            raise Exception(f"Processing failed: {e}")
    
    def extract_all_text(self, reader, output_path):
        """Extract text from all pages"""
        all_text = ""
        
        for page_num, page in enumerate(reader.pages):
            text = page.extract_text()
            all_text += f"\n--- Page {page_num + 1} ---\n"
            all_text += text
            all_text += "\n"
        
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(all_text)
    
    def split_pdf_to_pages(self, reader, output_dir, base_name):
        """Split PDF into individual page files"""
        for page_num, page in enumerate(reader.pages):
            writer = PdfWriter()
            writer.add_page(page)
            
            page_file = output_dir / f"{base_name}_page_{page_num + 1:03d}.pdf"
            with open(page_file, 'wb') as f:
                writer.write(f)
    
    def optimize_pdf(self, input_path, output_path):
        """Create optimized version of PDF"""
        reader = PdfReader(input_path)
        writer = PdfWriter()
        
        for page in reader.pages:
            # Compress page content
            page.compress_content_streams()
            writer.add_page(page)
        
        with open(output_path, 'wb') as f:
            writer.write(f)
    
    def generate_processing_report(self):
        """Generate comprehensive processing report"""
        report_data = {
            'processing_date': datetime.now().isoformat(),
            'total_files': len(self.processing_log),
            'successful': len([log for log in self.processing_log if log.get('status') == 'success']),
            'errors': len([log for log in self.processing_log if log.get('status') == 'error']),
            'details': self.processing_log
        }
        
        # Calculate statistics
        successful_files = [log for log in self.processing_log if log.get('status') == 'success']
        if successful_files:
            total_pages = sum(log.get('pages', 0) for log in successful_files)
            total_size = sum(log.get('size_bytes', 0) for log in successful_files)
            
            report_data['statistics'] = {
                'total_pages_processed': total_pages,
                'total_size_bytes': total_size,
                'average_pages_per_file': total_pages / len(successful_files),
                'average_file_size': total_size / len(successful_files)
            }
        
        # Save report as JSON
        report_path = self.output_dir / "reports" / f"processing_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        with open(report_path, 'w') as f:
            json.dump(report_data, f, indent=2)
        
        # Print summary
        print(f"\n{'='*50}")
        print("PROCESSING COMPLETE")
        print(f"{'='*50}")
        print(f"Total files: {report_data['total_files']}")
        print(f"Successful: {report_data['successful']}")
        print(f"Errors: {report_data['errors']}")
        
        if 'statistics' in report_data:
            stats = report_data['statistics']
            print(f"Total pages: {stats['total_pages_processed']}")
            print(f"Total size: {stats['total_size_bytes']:,} bytes")
        
        print(f"Report saved: {report_path}")

def automated_pdf_workflow(input_directory, output_directory):
    """Complete automated PDF processing workflow"""
    processor = PDFProcessor(input_directory, output_directory)
    processor.process_all_pdfs()

# Example usage
# automated_pdf_workflow("/path/to/input/pdfs", "/path/to/output")

# For processing a specific directory
# processor = PDFProcessor("./input_pdfs", "./processed_pdfs")
# processor.process_all_pdfs()
```

## 9. Web-based PDF Processing

### Flask Web Application for PDF Processing
```python
from flask import Flask, request, render_template, send_file, jsonify
import os
from werkzeug.utils import secure_filename
import PyPDF2
from io import BytesIO
import zipfile

app = Flask(__name__)
app.config['UPLOAD_FOLDER'] = 'uploads'
app.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024  # 16MB max file size

# Ensure upload directory exists
os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)

@app.route('/')
def index():
    return render_template('pdf_processor.html')

@app.route('/upload', methods=['POST'])
def upload_file():
    if 'file' not in request.files:
        return jsonify({'error': 'No file uploaded'}), 400
    
    file = request.files['file']
    if file.filename == '':
        return jsonify({'error': 'No file selected'}), 400
    
    if file and file.filename.lower().endswith('.pdf'):
        filename = secure_filename(file.filename)
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)
        file.save(file_path)
        
        # Process PDF and return info
        pdf_info = analyze_uploaded_pdf(file_path)
        return jsonify({
            'success': True,
            'filename': filename,
            'info': pdf_info
        })
    
    return jsonify({'error': 'Invalid file type'}), 400

@app.route('/split/<filename>')
def split_pdf(filename):
    file_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)
    
    if not os.path.exists(file_path):
        return jsonify({'error': 'File not found'}), 404
    
    try:
        reader = PdfReader(file_path)
        
        # Create zip file with split pages
        zip_buffer = BytesIO()
        with zipfile.ZipFile(zip_buffer, 'w') as zip_file:
            for page_num, page in enumerate(reader.pages):
                writer = PdfWriter()
                writer.add_page(page)
                
                page_buffer = BytesIO()
                writer.write(page_buffer)
                page_buffer.seek(0)
                
                zip_file.writestr(
                    f"page_{page_num + 1:03d}.pdf",
                    page_buffer.getvalue()
                )
        
        zip_buffer.seek(0)
        
        return send_file(
            zip_buffer,
            as_attachment=True,
            download_name=f"{filename.rsplit('.', 1)[0]}_split.zip",
            mimetype='application/zip'
        )
        
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/merge', methods=['POST'])
def merge_pdfs():
    if 'files' not in request.files:
        return jsonify({'error': 'No files uploaded'}), 400
    
    files = request.files.getlist('files')
    
    try:
        merger = PdfMerger()
        
        for file in files:
            if file.filename.lower().endswith('.pdf'):
                merger.append(file)
        
        output_buffer = BytesIO()
        merger.write(output_buffer)
        merger.close()
        output_buffer.seek(0)
        
        return send_file(
            output_buffer,
            as_attachment=True,
            download_name="merged_document.pdf",
            mimetype='application/pdf'
        )
        
    except Exception as e:
        return jsonify({'error': str(e)}), 500

def analyze_uploaded_pdf(file_path):
    """Analyze uploaded PDF and return information"""
    try:
        reader = PdfReader(file_path)
        
        info = {
            'pages': len(reader.pages),
            'encrypted': reader.is_encrypted,
            'size': os.path.getsize(file_path)
        }
        
        if reader.metadata:
            info['metadata'] = {
                'title': reader.metadata.get('/Title', 'Unknown'),
                'author': reader.metadata.get('/Author', 'Unknown'),
                'creator': reader.metadata.get('/Creator', 'Unknown')
            }
        
        return info
        
    except Exception as e:
        return {'error': str(e)}

# HTML template (save as templates/pdf_processor.html)
html_template = '''
<!DOCTYPE html>
<html>
<head>
    <title>PDF Processor</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; }
        .container { max-width: 800px; margin: 0 auto; }
        .upload-area { border: 2px dashed #ccc; padding: 40px; text-align: center; margin: 20px 0; }
        .button { background: #007cba; color: white; padding: 10px 20px; border: none; cursor: pointer; }
        .result { margin: 20px 0; padding: 15px; background: #f0f0f0; }
    </style>
</head>
<body>
    <div class="container">
        <h1>PDF Processor</h1>
        
        <div class="upload-area">
            <h3>Upload PDF</h3>
            <input type="file" id="pdfFile" accept=".pdf">
            <button class="button" onclick="uploadFile()">Upload & Analyze</button>
        </div>
        
        <div id="results"></div>
        
        <div class="upload-area">
            <h3>Merge PDFs</h3>
            <input type="file" id="mergeFiles" accept=".pdf" multiple>
            <button class="button" onclick="mergeFiles()">Merge PDFs</button>
        </div>
    </div>

    <script>
        function uploadFile() {
            const fileInput = document.getElementById('pdfFile');
            const file = fileInput.files[0];
            
            if (!file) {
                alert('Please select a file');
                return;
            }
            
            const formData = new FormData();
            formData.append('file', file);
            
            fetch('/upload', {
                method: 'POST',
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    displayResults(data);
                } else {
                    alert('Error: ' + data.error);
                }
            })
            .catch(error => {
                alert('Upload failed: ' + error);
            });
        }
        
        function displayResults(data) {
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = `
                <div class="result">
                    <h3>PDF Analysis: ${data.filename}</h3>
                    <p>Pages: ${data.info.pages}</p>
                    <p>Size: ${data.info.size} bytes</p>
                    <p>Encrypted: ${data.info.encrypted ? 'Yes' : 'No'}</p>
                    <button class="button" onclick="splitPDF('${data.filename}')">Split PDF</button>
                </div>
            `;
        }
        
        function splitPDF(filename) {
            window.location.href = '/split/' + filename;
        }
        
        function mergeFiles() {
            const fileInput = document.getElementById('mergeFiles');
            const files = fileInput.files;
            
            if (files.length < 2) {
                alert('Please select at least 2 PDF files to merge');
                return;
            }
            
            const formData = new FormData();
            for (let file of files) {
                formData.append('files', file);
            }
            
            fetch('/merge', {
                method: 'POST',
                body: formData
            })
            .then(response => response.blob())
            .then(blob => {
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'merged_document.pdf';
                a.click();
            })
            .catch(error => {
                alert('Merge failed: ' + error);
            });
        }
    </script>
</body>
</html>
'''

if __name__ == '__main__':
    # Create templates directory and save HTML template
    os.makedirs('templates', exist_ok=True)
    with open('templates/pdf_processor.html', 'w') as f:
        f.write(html_template)
    
    app.run(debug=True)
```

## Installation Requirements

```bash
# Core PDF libraries
pip install PyPDF2 pdfplumber reportlab

# HTML to PDF conversion
pip install weasyprint

# OCR capabilities
pip install pytesseract pdf2image pillow opencv-python

# Data analysis and visualization
pip install pandas matplotlib wordcloud

# Web application (optional)
pip install flask

# System dependencies (Ubuntu/Debian)
sudo apt-get install tesseract-ocr poppler-utils

# System dependencies (macOS)
brew install tesseract poppler
```

## Additional Resources

### Official Documentation
- **PyPDF2**: https://pypdf2.readthedocs.io/
- **pdfplumber**: https://github.com/jsvine/pdfplumber
- **ReportLab**: https://www.reportlab.com/docs/
- **WeasyPrint**: https://weasyprint.org/

### Community Resources
- PDF processing tutorials and examples
- Stack Overflow PDF manipulation questions
- GitHub repositories with PDF utilities
- Open source PDF tools and libraries

### Best Practices
- Always handle PDF encryption properly
- Use appropriate DPI settings for OCR (300 DPI recommended)
- Implement proper error handling for corrupted PDFs
- Consider memory usage for large PDF files
- Validate PDF integrity before processing
- Use compression for generated PDFs to reduce file size

Created: 2025-06-02
Updated: 2025-06-02
