# PYTHON IMAGING LIBRARY (PILLOW) COMPREHENSIVE GUIDE

## 1. INTRODUCTION

PIL (Python Imaging Library) is now maintained as Pillow, a fork of the original PIL. It provides extensive file format support, efficient internal representation, and powerful image processing capabilities.

### Installation
```python
pip install Pillow
```

## 2. BASIC IMAGE OPERATIONS

### Loading Images
```python
from PIL import Image

# Open an image
img = Image.open('sample.jpg')

# Display basic info
print(f"Format: {img.format}")
print(f"Size: {img.size}")
print(f"Mode: {img.mode}")

# Show the image
img.show()
```

### Saving Images
```python
# Save in different formats
img.save('sample_copy.jpg')
img.save('sample.png')
img.save('sample.webp', quality=80)  # With quality parameter
img.save('sample.pdf')  # Save as PDF
```

### Creating New Images
```python
# Create a blank RGB image
new_img = Image.new('RGB', (300, 200), color=(73, 109, 137))
new_img.save('new_blue.png')

# Create a blank image with transparency
transparent_img = Image.new('RGBA', (300, 200), color=(73, 109, 137, 128))
transparent_img.save('transparent.png')
```

## 3. IMAGE MANIPULATION

### Resizing
```python
# Simple resize
resized_img = img.resize((800, 600))
resized_img.save('resized.jpg')

# Resize with high-quality resampling
from PIL import Image
better_resized = img.resize((800, 600), Image.Resampling.LANCZOS)
better_resized.save('better_resized.jpg')

# Resize keeping aspect ratio
def resize_keeping_aspect(image, target_size):
    width, height = image.size
    ratio = min(target_size[0] / width, target_size[1] / height)
    new_size = (int(width * ratio), int(height * ratio))
    return image.resize(new_size, Image.Resampling.LANCZOS)

aspect_resized = resize_keeping_aspect(img, (800, 600))
aspect_resized.save('aspect_resized.jpg')
```

### Cropping
```python
# Crop format: (left, upper, right, lower)
cropped = img.crop((100, 100, 400, 400))
cropped.save('cropped.jpg')

# Center crop
def center_crop(image, crop_size):
    width, height = image.size
    left = (width - crop_size[0]) // 2
    top = (height - crop_size[1]) // 2
    right = left + crop_size[0]
    bottom = top + crop_size[1]
    return image.crop((left, top, right, bottom))

center_cropped = center_crop(img, (300, 300))
center_cropped.save('center_cropped.jpg')
```

### Rotation and Flipping
```python
# Simple rotation
rotated_90 = img.rotate(90)
rotated_90.save('rotated_90.jpg')

# Rotation with expanded canvas to fit the entire image
rotated_45 = img.rotate(45, expand=True)
rotated_45.save('rotated_45.jpg')

# Flip horizontally (mirror)
flipped_h = img.transpose(Image.Transpose.FLIP_LEFT_RIGHT)
flipped_h.save('flipped_h.jpg')

# Flip vertically
flipped_v = img.transpose(Image.Transpose.FLIP_TOP_BOTTOM)
flipped_v.save('flipped_v.jpg')
```

## 4. COLOR MANIPULATION

### Color Modes
```python
# Convert to grayscale
grayscale = img.convert('L')
grayscale.save('grayscale.jpg')

# Convert to black and white (1-bit)
bw = img.convert('1')
bw.save('bw.jpg')

# Convert to CMYK (for print)
cmyk = img.convert('CMYK')
cmyk.save('cmyk.jpg')

# Convert to RGB from another mode
rgb = cmyk.convert('RGB')
rgb.save('back_to_rgb.jpg')
```

### Adjusting Colors
```python
from PIL import ImageEnhance

# Adjust brightness
enhancer = ImageEnhance.Brightness(img)
brightened = enhancer.enhance(1.5)  # 1.0 is original, >1.0 brightens, <1.0 darkens
brightened.save('brightened.jpg')

# Adjust contrast
enhancer = ImageEnhance.Contrast(img)
contrasted = enhancer.enhance(1.5)
contrasted.save('contrasted.jpg')

# Adjust saturation
enhancer = ImageEnhance.Color(img)
saturated = enhancer.enhance(1.7)
saturated.save('saturated.jpg')

# Adjust sharpness
enhancer = ImageEnhance.Sharpness(img)
sharpened = enhancer.enhance(2.0)
sharpened.save('sharpened.jpg')
```

## 5. FILTERS AND EFFECTS

### Built-in Filters
```python
from PIL import ImageFilter

# Blur
blurred = img.filter(ImageFilter.BLUR)
blurred.save('blurred.jpg')

# Gaussian blur with radius
gaussian_blurred = img.filter(ImageFilter.GaussianBlur(radius=10))
gaussian_blurred.save('gaussian_blurred.jpg')

# Find edges
edges = img.filter(ImageFilter.FIND_EDGES)
edges.save('edges.jpg')

# Emboss
embossed = img.filter(ImageFilter.EMBOSS)
embossed.save('embossed.jpg')

# Enhance edges
edge_enhanced = img.filter(ImageFilter.EDGE_ENHANCE_MORE)
edge_enhanced.save('edge_enhanced.jpg')

# Sharpen
sharpened_filter = img.filter(ImageFilter.SHARPEN)
sharpened_filter.save('sharpened_filter.jpg')

# Contour
contoured = img.filter(ImageFilter.CONTOUR)
contoured.save('contoured.jpg')

# Detail
detailed = img.filter(ImageFilter.DETAIL)
detailed.save('detailed.jpg')
```

### Custom Filters
```python
# Custom kernel filter
custom_kernel = ImageFilter.Kernel(
    size=(3, 3),
    kernel=[-1, -1, -1, -1, 8, -1, -1, -1, -1],
    scale=1
)
custom_filtered = img.filter(custom_kernel)
custom_filtered.save('custom_filter.jpg')
```

## 6. DRAWING ON IMAGES

```python
from PIL import Image, ImageDraw, ImageFont

# Create a blank canvas
canvas = Image.new('RGB', (400, 300), color='white')
draw = ImageDraw.Draw(canvas)

# Draw shapes
draw.line([(0, 0), (400, 300)], fill='red', width=5)
draw.rectangle([(50, 50), (350, 250)], outline='blue', width=2)
draw.ellipse([(100, 100), (300, 200)], fill='green', outline='black')
draw.polygon([(200, 50), (300, 150), (200, 250), (100, 150)], fill='yellow')

# Draw text
try:
    # Try to use a TrueType font if available
    font = ImageFont.truetype("arial.ttf", 24)
except IOError:
    # Fall back to default font
    font = ImageFont.load_default()

draw.text((150, 20), "PIL Drawing", fill='purple', font=font)

# Save the drawing
canvas.save('drawing.png')

# Draw on existing image
draw_on_img = ImageDraw.Draw(img)
draw_on_img.rectangle([(20, 20), (img.width-20, img.height-20)], outline='white', width=5)
img.save('outlined_photo.jpg')
```

## 7. IMAGE COMPOSITING AND TRANSPARENCY

### Alpha Compositing
```python
# Create two images with alpha
foreground = Image.new('RGBA', (200, 200), (255, 0, 0, 128))  # Semi-transparent red
background = Image.new('RGBA', (400, 400), (0, 0, 255, 255))  # Solid blue

# Paste with alpha
background.paste(foreground, (100, 100), foreground)
background.save('composite_alpha.png')
```

### Creating Thumbnails
```python
# Create a thumbnail (modifies image in-place)
thumb_img = img.copy()
thumb_img.thumbnail((128, 128))  # Keeps aspect ratio
thumb_img.save('thumbnail.jpg')
```

### Image Watermarking
```python
def add_watermark(image, watermark_text):
    # Create a copy to avoid modifying original
    result = image.copy().convert('RGBA')
    
    # Create transparent overlay
    overlay = Image.new('RGBA', result.size, (0, 0, 0, 0))
    draw = ImageDraw.Draw(overlay)
    
    try:
        font = ImageFont.truetype("arial.ttf", 50)
    except IOError:
        font = ImageFont.load_default()
    
    # Calculate text size and position
    text_width = draw.textlength(watermark_text, font=font)
    x = (result.width - text_width) / 2
    y = result.height / 2
    
    # Draw semi-transparent text
    draw.text((x, y), watermark_text, font=font, fill=(255, 255, 255, 128))
    
    # Composite the watermark with the image
    watermarked = Image.alpha_composite(result, overlay)
    return watermarked.convert('RGB')  # Convert back to RGB for saving as JPG

watermarked = add_watermark(img, "Copyright 2025")
watermarked.save('watermarked.jpg')
```

## 8. IMAGE ANALYSIS

### Getting Pixel Data
```python
# Get a single pixel
pixel = img.getpixel((100, 100))
print(f"Pixel at (100, 100): {pixel}")

# Convert to NumPy array for advanced operations
import numpy as np
img_array = np.array(img)
print(f"Image shape: {img_array.shape}")
```

### Histograms
```python
# Get histogram data
hist = img.histogram()

# Plot histogram with matplotlib
import matplotlib.pyplot as plt

def plot_histogram(image):
    # For RGB images
    if image.mode == 'RGB':
        plt.figure(figsize=(15, 5))
        colors = ('red', 'green', 'blue')
        for i, color in enumerate(colors):
            histogram = image.histogram()[i*256:(i+1)*256]
            plt.subplot(1, 3, i+1)
            plt.bar(range(256), histogram, color=color)
            plt.title(f'{color} channel')
        plt.savefig('histogram_rgb.png')
    # For grayscale
    elif image.mode == 'L':
        plt.figure(figsize=(10, 5))
        plt.bar(range(256), image.histogram(), color='gray')
        plt.title('Grayscale Histogram')
        plt.savefig('histogram_gray.png')

# Plot histogram for original image
plot_histogram(img)
# Plot histogram for grayscale
plot_histogram(img.convert('L'))
```

### Image Statistics
```python
from PIL import ImageStat

stats = ImageStat.Stat(img)
print(f"Mean values per channel: {stats.mean}")
print(f"Median values per channel: {stats.median}")
print(f"Standard deviation per channel: {stats.stddev}")
print(f"Min values per channel: {stats.extrema[0]}")
print(f"Max values per channel: {stats.extrema[1]}")
```

## 9. BATCH PROCESSING

### Process Multiple Files
```python
import os

def batch_process(input_dir, output_dir, operation, *args, **kwargs):
    """
    Apply an operation to all images in a directory
    
    Args:
        input_dir: Directory with source images
        output_dir: Directory to save processed images
        operation: Function that takes an image and returns processed image
        *args, **kwargs: Additional arguments for the operation
    """
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)
        
    for filename in os.listdir(input_dir):
        if filename.lower().endswith(('.png', '.jpg', '.jpeg', '.bmp', '.gif')):
            input_path = os.path.join(input_dir, filename)
            output_path = os.path.join(output_dir, filename)
            
            try:
                with Image.open(input_path) as img:
                    processed = operation(img, *args, **kwargs)
                    processed.save(output_path)
                    print(f"Processed {filename}")
            except Exception as e:
                print(f"Error processing {filename}: {e}")

# Example: Resize all images in a directory
def resize_operation(image, size):
    return image.resize(size, Image.Resampling.LANCZOS)

# Usage
# batch_process("input_images", "resized_images", resize_operation, (800, 600))
```

## 10. ADVANCED TECHNIQUES

### Image Sequences and Animation
```python
# Create a GIF animation
def create_animated_gif(images, output_filename, duration=100):
    """
    Create an animated GIF from a list of images
    
    Args:
        images: List of PIL Image objects or filenames
        output_filename: Output GIF filename
        duration: Frame duration in milliseconds
    """
    # Convert filenames to images if needed
    frames = []
    for img in images:
        if isinstance(img, str):
            frames.append(Image.open(img))
        else:
            frames.append(img)
    
    # Save as animated GIF
    frames[0].save(
        output_filename,
        save_all=True,
        append_images=frames[1:],
        optimize=True,
        duration=duration,
        loop=0  # 0 means loop forever
    )

# Example: Create a pulsing circle animation
def create_pulsing_circle():
    frames = []
    for radius in range(10, 100, 5) + range(100, 10, -5):
        frame = Image.new('RGB', (200, 200), (0, 0, 0))
        draw = ImageDraw.Draw(frame)
        draw.ellipse(
            [(100-radius, 100-radius), (100+radius, 100+radius)],
            fill=(int(255*(radius/100)), 64, 255-int(255*(radius/100)))
        )
        frames.append(frame)
    
    create_animated_gif(frames, "pulsing_circle.gif", 50)

# Example: Split frames from an animated GIF
def extract_gif_frames(gif_path, output_dir):
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)
        
    with Image.open(gif_path) as gif:
        for i in range(gif.n_frames):
            gif.seek(i)
            frame = gif.copy()
            frame.save(os.path.join(output_dir, f"frame_{i:03d}.png"))
```

### Working with Metadata
```python
from PIL import Image, ExifTags

def print_exif(image_path):
    """Print EXIF data for an image"""
    with Image.open(image_path) as img:
        # Check if image has EXIF data
        if hasattr(img, '_getexif') and img._getexif() is not None:
            exif_data = img._getexif()
            for tag_id, value in exif_data.items():
                # Get the tag name
                tag = ExifTags.TAGS.get(tag_id, tag_id)
                print(f"{tag}: {value}")
        else:
            print("No EXIF data found")

# Example: Preserve EXIF when processing
def preserve_exif_resize(input_path, output_path, size):
    """Resize an image while preserving EXIF data"""
    with Image.open(input_path) as img:
        # Store EXIF data
        exif_data = None
        if hasattr(img, '_getexif') and img._getexif() is not None:
            exif_dict = img._getexif()
            if exif_dict:
                exif_data = img.info.get('exif')
                
        # Process image
        resized = img.resize(size, Image.Resampling.LANCZOS)
        
        # Save with original EXIF
        if exif_data:
            resized.save(output_path, exif=exif_data)
        else:
            resized.save(output_path)
```

### Image Transformations
```python
from PIL import Image

# Perspective transformation
def perspective_transform(img, coeffs):
    """
    Apply perspective transformation
    
    Args:
        img: Source image
        coeffs: 8-tuple (x0,y0,x1,y1,x2,y2,x3,y3) containing
               the coordinates of the corners in the output image
    """
    width, height = img.size
    # The 4 corners of the source image
    src_corners = [(0, 0), (width-1, 0), (width-1, height-1), (0, height-1)]
    # Convert destination corners to format expected by transform method
    dest_corners = [coeffs[0:2], coeffs[2:4], coeffs[4:6], coeffs[6:8]]
    
    # Calculate transformation coefficients
    from PIL import Image
    transformed = img.transform(
        (width, height),
        Image.Transform.QUAD,
        data=sum(src_corners + dest_corners, ()),  # Flatten the coordinate lists
        resample=Image.Resampling.BICUBIC
    )
    
    return transformed

# Example: Apply perspective to make image look like a sign on a wall
coeffs = (20, 20, 280, 10, 300, 190, 10, 210)  # Destination corners
transformed = perspective_transform(img, coeffs)
transformed.save('perspective.jpg')
```

### Combining with OpenCV
```python
# Using PIL with OpenCV for advanced processing
import cv2
import numpy as np
from PIL import Image

def pil_to_opencv(pil_image):
    """Convert PIL Image to OpenCV format (numpy array)"""
    # Convert to RGB if needed (OpenCV uses BGR)
    if pil_image.mode != 'RGB':
        pil_image = pil_image.convert('RGB')
    # Convert to numpy array and change color channel order
    opencv_image = np.array(pil_image)
    # Convert RGB to BGR
    opencv_image = opencv_image[:, :, ::-1].copy()
    return opencv_image

def opencv_to_pil(opencv_image):
    """Convert OpenCV image to PIL Image"""
    # Convert BGR to RGB
    rgb_image = opencv_image[:, :, ::-1]
    # Convert to PIL Image
    pil_image = Image.fromarray(rgb_image)
    return pil_image

# Example: Use OpenCV for edge detection
def canny_edge_detection(pil_image, threshold1=100, threshold2=200):
    # Convert PIL to OpenCV
    cv_image = pil_to_opencv(pil_image)
    
    # Convert to grayscale
    gray = cv2.cvtColor(cv_image, cv2.COLOR_BGR2GRAY)
    
    # Apply Canny edge detection
    edges = cv2.Canny(gray, threshold1, threshold2)
    
    # Convert back to PIL (need to convert to RGB as Canny returns grayscale)
    result = Image.fromarray(edges).convert('RGB')
    return result

# Apply Canny edge detection
edges = canny_edge_detection(img)
edges.save('canny_edges.jpg')
```

## 11. ERROR HANDLING AND BEST PRACTICES

```python
def safe_image_open(file_path):
    """Safely open an image file with proper error handling"""
    try:
        img = Image.open(file_path)
        # Verify the image can be read
        img.verify()
        # Re-open because verify closes the file
        img = Image.open(file_path)
        return img
    except FileNotFoundError:
        print(f"File not found: {file_path}")
    except Image.DecompressionBombError:
        print(f"Image is too large and might cause memory issues: {file_path}")
    except Image.UnidentifiedImageError:
        print(f"Cannot identify image file: {file_path}")
    except Exception as e:
        print(f"Error opening image {file_path}: {e}")
    return None

# Memory-efficient processing for large images
def process_large_image(file_path, operation, tile_size=1024, output_path=None):
    """
    Process a large image in tiles to avoid memory issues
    
    Args:
        file_path: Path to image file
        operation: Function to apply to each tile
        tile_size: Size of square tiles to process
        output_path: Where to save the result (if None, uses original path)
    """
    if output_path is None:
        output_path = file_path
        
    # Open the image (but don't load it entirely into memory)
    with Image.open(file_path) as img:
        # Create output image with same size and mode
        result = Image.new(img.mode, img.size)
        
        # Process image in tiles
        for y in range(0, img.height, tile_size):
            for x in range(0, img.width, tile_size):
                # Calculate tile dimensions
                box = (x, y, min(x + tile_size, img.width), min(y + tile_size, img.height))
                # Get the tile
                tile = img.crop(box)
                # Process the tile
                processed_tile = operation(tile)
                # Paste it back
                result.paste(processed_tile, box)
                
        # Save result
        result.save(output_path)
        return result
```

## 12. PILLOW AND OTHER LIBRARIES

### Working with NumPy
```python
import numpy as np
from PIL import Image

# Convert PIL Image to NumPy array
img_array = np.array(img)
print(f"Array shape: {img_array.shape}, dtype: {img_array.dtype}")

# Manipulate with NumPy
# Example: Invert colors
inverted_array = 255 - img_array
inverted_img = Image.fromarray(inverted_array)
inverted_img.save('inverted.jpg')

# Example: Adjust brightness with NumPy
brightened_array = np.clip(img_array * 1.5, 0, 255).astype(np.uint8)
brightened_img = Image.fromarray(brightened_array)
brightened_img.save('numpy_brightened.jpg')

# Example: Split and merge channels
r_channel = img_array.copy()
r_channel[:, :, 1:3] = 0  # Zero out G and B channels
r_img = Image.fromarray(r_channel)
r_img.save('red_channel.jpg')
```

### Integration with matplotlib
```python
import matplotlib.pyplot as plt

def display_images(images, titles=None, figsize=(15, 10), cmaps=None):
    """
    Display multiple images in a grid
    
    Args:
        images: List of PIL Images or numpy arrays
        titles: List of titles for each image
        figsize: Figure size (width, height)
        cmaps: List of colormaps for each image (for grayscale images)
    """
    n = len(images)
    cols = min(3, n)
    rows = (n + cols - 1) // cols
    
    fig, axes = plt.subplots(rows, cols, figsize=figsize)
    if rows == 1 and cols == 1:
        axes = [axes]
    elif rows == 1 or cols == 1:
        axes = axes.flatten()
        
    for i, img in enumerate(images):
        if i < len(axes):
            # Convert PIL image to numpy if needed
            if isinstance(img, Image.Image):
                img = np.array(img)
                
            # Get cmap if provided
            cmap = None
            if cmaps and i < len(cmaps):
                cmap = cmaps[i]
            
            # Display image
            axes[i].imshow(img, cmap=cmap)
            axes[i].axis('off')
            
            # Add title if provided
            if titles and i < len(titles):
                axes[i].set_title(titles[i])
    
    # Hide unused subplots
    for i in range(len(images), len(axes)):
        fig.delaxes(axes[i])
    
    plt.tight_layout()
    plt.savefig('comparison.png')
    plt.show()

# Example: Compare different processing methods
original = img
grayscale = img.convert('L')
blurred = img.filter(ImageFilter.GaussianBlur(radius=5))
edge_enhanced = img.filter(ImageFilter.EDGE_ENHANCE_MORE)

# Convert grayscale to RGB for consistent display
grayscale_rgb = grayscale.convert('RGB')

display_images(
    [original, grayscale_rgb, blurred, edge_enhanced],
    titles=['Original', 'Grayscale', 'Blurred', 'Edge Enhanced'],
    figsize=(12, 8)
)
```

## 13. COMMON USE CASES AND RECIPES

### Create a Contact Sheet/Image Grid
```python
def create_contact_sheet(images, grid_size, thumbnail_size=(200, 200)):
    """
    Create a contact sheet from multiple images
    
    Args:
        images: List of PIL images or file paths
        grid_size: Tuple of (columns, rows)
        thumbnail_size: Size for each thumbnail
    
    Returns:
        PIL Image with the contact sheet
    """
    # Load images if file paths were provided
    loaded_images = []
    for img in images:
        if isinstance(img, str):
            loaded_images.append(Image.open(img))
        else:
            loaded_images.append(img)
    
    # Create thumbnails
    thumbnails = []
    for img in loaded_images:
        # Create a copy to avoid modifying original
        thumb = img.copy()
        thumb.thumbnail(thumbnail_size)
        thumbnails.append(thumb)
    
    # Create blank canvas
    cols, rows = grid_size
    sheet_width = thumbnail_size[0] * cols
    sheet_height = thumbnail_size[1] * rows
    contact_sheet = Image.new('RGB', (sheet_width, sheet_height), (255, 255, 255))
    
    # Paste thumbnails onto contact sheet
    for idx, thumb in enumerate(thumbnails):
        if idx >= cols * rows:
            break  # Stop if we've filled the grid
        
        # Calculate position
        row = idx // cols
        col = idx % cols
        x = col * thumbnail_size[0]
        y = row * thumbnail_size[1]
        
        # Center the thumbnail if smaller than thumbnail_size
        x_offset = (thumbnail_size[0] - thumb.width) // 2
        y_offset = (thumbnail_size[1] - thumb.height) // 2
        
        contact_sheet.paste(thumb, (x + x_offset, y + y_offset))
    
    return contact_sheet
```

### Add Borders and Frames
```python
def add_border(image, border_width=10, color=(255, 255, 255)):
    """Add a border around an image"""
    width, height = image.size
    new_width = width + 2 * border_width
    new_height = height + 2 * border_width
    
    bordered = Image.new(image.mode, (new_width, new_height), color)
    bordered.paste(image, (border_width, border_width))
    
    return bordered

def add_gradient_border(image, border_width=20, colors=[(255,0,0), (0,0,255)]):
    """Add a gradient border around an image"""
    from PIL import ImageDraw
    
    # Create new image with border
    width, height = image.size
    new_width = width + 2 * border_width
    new_height = height + 2 * border_width
    
    # Create blank image with first color
    result = Image.new('RGB', (new_width, new_height), colors[0])
    
    # Draw gradient (simplified - just horizontal gradient)
    draw = ImageDraw.Draw(result)
    for i in range(border_width):
        # Calculate color for this pixel based on position
        t = i / border_width
        r = int(colors[0][0] * (1 - t) + colors[1][0] * t)
        g = int(colors[0][1] * (1 - t) + colors[1][1] * t)
        b = int(colors[0][2] * (1 - t) + colors[1][2] * t)
        color = (r, g, b)
        
        # Draw top and bottom lines
        draw.line([(0, i), (new_width-1, i)], fill=color)
        draw.line([(0, new_height-i-1), (new_width-1, new_height-i-1)], fill=color)
        
        # Draw left and right lines
        draw.line([(i, 0), (i, new_height-1)], fill=color)
        draw.line([(new_width-i-1, 0), (new_width-i-1, new_height-1)], fill=color)
    
    # Paste original image
    result.paste(image, (border_width, border_width))
    return result

def add_photo_frame(image, frame_width=50, frame_color=(139, 69, 19)):
    """Add a photo frame with shadow effect"""
    width, height = image.size
    new_width = width + 2 * frame_width
    new_height = height + 2 * frame_width
    
    # Create the frame image
    framed = Image.new('RGB', (new_width, new_height), frame_color)
    
    # Create a drop shadow (black rectangle slightly offset)
    shadow = Image.new('RGBA', (width, height), (0, 0, 0, 180))
    framed.paste(shadow, (frame_width + 5, frame_width + 5), shadow)
    
    # Paste the original image
    framed.paste(image, (frame_width, frame_width))
    
    return framed
```

### Create a Watermark
```python
def add_text_watermark(image, text, position=None, color=(255, 255, 255, 128), font_size=40):
    """Add a text watermark to an image"""
    from PIL import ImageDraw, ImageFont
    
    # Create a transparent overlay
    overlay = Image.new('RGBA', image.size, (0, 0, 0, 0))
    draw = ImageDraw.Draw(overlay)
    
    try:
        font = ImageFont.truetype("arial.ttf", font_size)
    except IOError:
        font = ImageFont.load_default()
    
    # Calculate text size
    text_width = draw.textlength(text, font=font)
    
    # Set position (center by default)
    if position is None:
        position = ((image.width - text_width) // 2, image.height // 2)
    
    # Draw the text
    draw.text(position, text, font=font, fill=color)
    
    # Convert image to RGBA if it isn't already
    if image.mode != 'RGBA':
        image = image.convert('RGBA')
    
    # Composite the watermarked image
    watermarked = Image.alpha_composite(image, overlay)
    return watermarked

def add_image_watermark(image, watermark_image, position=None, opacity=0.3):
    """Add an image watermark to another image"""
    # Ensure the watermark has an alpha channel
    if watermark_image.mode != 'RGBA':
        watermark_image = watermark_image.convert('RGBA')
    
    # Create a copy of the watermark with desired opacity
    watermark = watermark_image.copy()
    alpha = watermark.split()[3]
    alpha = alpha.point(lambda x: int(x * opacity))
    watermark.putalpha(alpha)
    
    # Ensure base image has alpha channel
    if image.mode != 'RGBA':
        image = image.convert('RGBA')
    
    # Set position (center by default)
    if position is None:
        position = ((image.width - watermark.width) // 2, 
                   (image.height - watermark.height) // 2)
    
    # Create a new blank image with same size as original
    result = Image.new('RGBA', image.size, (0, 0, 0, 0))
    
    # Paste the original image
    result.paste(image, (0, 0))
    
    # Paste the watermark
    result.paste(watermark, position, watermark)
    
    return result
```

## 14. CONCLUSION

Pillow (PIL) is a powerful library for image processing in Python. It provides a wide range of functionality for working with images, from simple operations like resizing and cropping to more complex transformations and effects. This guide covers many common uses, but there's always more to explore in the official documentation.

Remember to consider performance and memory constraints when working with large images, and always handle errors appropriately to make your image processing applications robust.

For the latest information and updates, visit the official Pillow documentation: https://pillow.readthedocs.io/
```

I've created a comprehensive guide covering all major aspects of using PIL (Pillow) with numerous practical examples. The document includes basic operations, image manipulation techniques, color adjustments, filters, drawing capabilities, compositing, analysis tools, batch processing, and integration with other libraries.

Would you like me to expand on any particular section or add more examples for a specific functionality?# filepath: use-PIL_Guide.txt

# PYTHON IMAGING LIBRARY (PILLOW) COMPREHENSIVE GUIDE

## 1. INTRODUCTION

PIL (Python Imaging Library) is now maintained as Pillow, a fork of the original PIL. It provides extensive file format support, efficient internal representation, and powerful image processing capabilities.

### Installation
```python
pip install Pillow
```

## 2. BASIC IMAGE OPERATIONS

### Loading Images
```python
from PIL import Image

# Open an image
img = Image.open('sample.jpg')

# Display basic info
print(f"Format: {img.format}")
print(f"Size: {img.size}")
print(f"Mode: {img.mode}")

# Show the image
img.show()
```

### Saving Images
```python
# Save in different formats
img.save('sample_copy.jpg')
img.save('sample.png')
img.save('sample.webp', quality=80)  # With quality parameter
img.save('sample.pdf')  # Save as PDF
```

### Creating New Images
```python
# Create a blank RGB image
new_img = Image.new('RGB', (300, 200), color=(73, 109, 137))
new_img.save('new_blue.png')

# Create a blank image with transparency
transparent_img = Image.new('RGBA', (300, 200), color=(73, 109, 137, 128))
transparent_img.save('transparent.png')
```

## 3. IMAGE MANIPULATION

### Resizing
```python
# Simple resize
resized_img = img.resize((800, 600))
resized_img.save('resized.jpg')

# Resize with high-quality resampling
from PIL import Image
better_resized = img.resize((800, 600), Image.Resampling.LANCZOS)
better_resized.save('better_resized.jpg')

# Resize keeping aspect ratio
def resize_keeping_aspect(image, target_size):
    width, height = image.size
    ratio = min(target_size[0] / width, target_size[1] / height)
    new_size = (int(width * ratio), int(height * ratio))
    return image.resize(new_size, Image.Resampling.LANCZOS)

aspect_resized = resize_keeping_aspect(img, (800, 600))
aspect_resized.save('aspect_resized.jpg')
```

### Cropping
```python
# Crop format: (left, upper, right, lower)
cropped = img.crop((100, 100, 400, 400))
cropped.save('cropped.jpg')

# Center crop
def center_crop(image, crop_size):
    width, height = image.size
    left = (width - crop_size[0]) // 2
    top = (height - crop_size[1]) // 2
    right = left + crop_size[0]
    bottom = top + crop_size[1]
    return image.crop((left, top, right, bottom))

center_cropped = center_crop(img, (300, 300))
center_cropped.save('center_cropped.jpg')
```

### Rotation and Flipping
```python
# Simple rotation
rotated_90 = img.rotate(90)
rotated_90.save('rotated_90.jpg')

# Rotation with expanded canvas to fit the entire image
rotated_45 = img.rotate(45, expand=True)
rotated_45.save('rotated_45.jpg')

# Flip horizontally (mirror)
flipped_h = img.transpose(Image.Transpose.FLIP_LEFT_RIGHT)
flipped_h.save('flipped_h.jpg')

# Flip vertically
flipped_v = img.transpose(Image.Transpose.FLIP_TOP_BOTTOM)
flipped_v.save('flipped_v.jpg')
```

## 4. COLOR MANIPULATION

### Color Modes
```python
# Convert to grayscale
grayscale = img.convert('L')
grayscale.save('grayscale.jpg')

# Convert to black and white (1-bit)
bw = img.convert('1')
bw.save('bw.jpg')

# Convert to CMYK (for print)
cmyk = img.convert('CMYK')
cmyk.save('cmyk.jpg')

# Convert to RGB from another mode
rgb = cmyk.convert('RGB')
rgb.save('back_to_rgb.jpg')
```

### Adjusting Colors
```python
from PIL import ImageEnhance

# Adjust brightness
enhancer = ImageEnhance.Brightness(img)
brightened = enhancer.enhance(1.5)  # 1.0 is original, >1.0 brightens, <1.0 darkens
brightened.save('brightened.jpg')

# Adjust contrast
enhancer = ImageEnhance.Contrast(img)
contrasted = enhancer.enhance(1.5)
contrasted.save('contrasted.jpg')

# Adjust saturation
enhancer = ImageEnhance.Color(img)
saturated = enhancer.enhance(1.7)
saturated.save('saturated.jpg')

# Adjust sharpness
enhancer = ImageEnhance.Sharpness(img)
sharpened = enhancer.enhance(2.0)
sharpened.save('sharpened.jpg')
```

## 5. FILTERS AND EFFECTS

### Built-in Filters
```python
from PIL import ImageFilter

# Blur
blurred = img.filter(ImageFilter.BLUR)
blurred.save('blurred.jpg')

# Gaussian blur with radius
gaussian_blurred = img.filter(ImageFilter.GaussianBlur(radius=10))
gaussian_blurred.save('gaussian_blurred.jpg')

# Find edges
edges = img.filter(ImageFilter.FIND_EDGES)
edges.save('edges.jpg')

# Emboss
embossed = img.filter(ImageFilter.EMBOSS)
embossed.save('embossed.jpg')

# Enhance edges
edge_enhanced = img.filter(ImageFilter.EDGE_ENHANCE_MORE)
edge_enhanced.save('edge_enhanced.jpg')

# Sharpen
sharpened_filter = img.filter(ImageFilter.SHARPEN)
sharpened_filter.save('sharpened_filter.jpg')

# Contour
contoured = img.filter(ImageFilter.CONTOUR)
contoured.save('contoured.jpg')

# Detail
detailed = img.filter(ImageFilter.DETAIL)
detailed.save('detailed.jpg')
```

### Custom Filters
```python
# Custom kernel filter
custom_kernel = ImageFilter.Kernel(
    size=(3, 3),
    kernel=[-1, -1, -1, -1, 8, -1, -1, -1, -1],
    scale=1
)
custom_filtered = img.filter(custom_kernel)
custom_filtered.save('custom_filter.jpg')
```

## 6. DRAWING ON IMAGES

```python
from PIL import Image, ImageDraw, ImageFont

# Create a blank canvas
canvas = Image.new('RGB', (400, 300), color='white')
draw = ImageDraw.Draw(canvas)

# Draw shapes
draw.line([(0, 0), (400, 300)], fill='red', width=5)
draw.rectangle([(50, 50), (350, 250)], outline='blue', width=2)
draw.ellipse([(100, 100), (300, 200)], fill='green', outline='black')
draw.polygon([(200, 50), (300, 150), (200, 250), (100, 150)], fill='yellow')

# Draw text
try:
    # Try to use a TrueType font if available
    font = ImageFont.truetype("arial.ttf", 24)
except IOError:
    # Fall back to default font
    font = ImageFont.load_default()

draw.text((150, 20), "PIL Drawing", fill='purple', font=font)

# Save the drawing
canvas.save('drawing.png')

# Draw on existing image
draw_on_img = ImageDraw.Draw(img)
draw_on_img.rectangle([(20, 20), (img.width-20, img.height-20)], outline='white', width=5)
img.save('outlined_photo.jpg')
```

## 7. IMAGE COMPOSITING AND TRANSPARENCY

### Alpha Compositing
```python
# Create two images with alpha
foreground = Image.new('RGBA', (200, 200), (255, 0, 0, 128))  # Semi-transparent red
background = Image.new('RGBA', (400, 400), (0, 0, 255, 255))  # Solid blue

# Paste with alpha
background.paste(foreground, (100, 100), foreground)
background.save('composite_alpha.png')
```

### Creating Thumbnails
```python
# Create a thumbnail (modifies image in-place)
thumb_img = img.copy()
thumb_img.thumbnail((128, 128))  # Keeps aspect ratio
thumb_img.save('thumbnail.jpg')
```

### Image Watermarking
```python
def add_watermark(image, watermark_text):
    # Create a copy to avoid modifying original
    result = image.copy().convert('RGBA')
    
    # Create transparent overlay
    overlay = Image.new('RGBA', result.size, (0, 0, 0, 0))
    draw = ImageDraw.Draw(overlay)
    
    try:
        font = ImageFont.truetype("arial.ttf", 50)
    except IOError:
        font = ImageFont.load_default()
    
    # Calculate text size and position
    text_width = draw.textlength(watermark_text, font=font)
    x = (result.width - text_width) / 2
    y = result.height / 2
    
    # Draw semi-transparent text
    draw.text((x, y), watermark_text, font=font, fill=(255, 255, 255, 128))
    
    # Composite the watermark with the image
    watermarked = Image.alpha_composite(result, overlay)
    return watermarked.convert('RGB')  # Convert back to RGB for saving as JPG

watermarked = add_watermark(img, "Copyright 2025")
watermarked.save('watermarked.jpg')
```

## 8. IMAGE ANALYSIS

### Getting Pixel Data
```python
# Get a single pixel
pixel = img.getpixel((100, 100))
print(f"Pixel at (100, 100): {pixel}")

# Convert to NumPy array for advanced operations
import numpy as np
img_array = np.array(img)
print(f"Image shape: {img_array.shape}")
```

### Histograms
```python
# Get histogram data
hist = img.histogram()

# Plot histogram with matplotlib
import matplotlib.pyplot as plt

def plot_histogram(image):
    # For RGB images
    if image.mode == 'RGB':
        plt.figure(figsize=(15, 5))
        colors = ('red', 'green', 'blue')
        for i, color in enumerate(colors):
            histogram = image.histogram()[i*256:(i+1)*256]
            plt.subplot(1, 3, i+1)
            plt.bar(range(256), histogram, color=color)
            plt.title(f'{color} channel')
        plt.savefig('histogram_rgb.png')
    # For grayscale
    elif image.mode == 'L':
        plt.figure(figsize=(10, 5))
        plt.bar(range(256), image.histogram(), color='gray')
        plt.title('Grayscale Histogram')
        plt.savefig('histogram_gray.png')

# Plot histogram for original image
plot_histogram(img)
# Plot histogram for grayscale
plot_histogram(img.convert('L'))
```

### Image Statistics
```python
from PIL import ImageStat

stats = ImageStat.Stat(img)
print(f"Mean values per channel: {stats.mean}")
print(f"Median values per channel: {stats.median}")
print(f"Standard deviation per channel: {stats.stddev}")
print(f"Min values per channel: {stats.extrema[0]}")
print(f"Max values per channel: {stats.extrema[1]}")
```

## 9. BATCH PROCESSING

### Process Multiple Files
```python
import os

def batch_process(input_dir, output_dir, operation, *args, **kwargs):
    """
    Apply an operation to all images in a directory
    
    Args:
        input_dir: Directory with source images
        output_dir: Directory to save processed images
        operation: Function that takes an image and returns processed image
        *args, **kwargs: Additional arguments for the operation
    """
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)
        
    for filename in os.listdir(input_dir):
        if filename.lower().endswith(('.png', '.jpg', '.jpeg', '.bmp', '.gif')):
            input_path = os.path.join(input_dir, filename)
            output_path = os.path.join(output_dir, filename)
            
            try:
                with Image.open(input_path) as img:
                    processed = operation(img, *args, **kwargs)
                    processed.save(output_path)
                    print(f"Processed {filename}")
            except Exception as e:
                print(f"Error processing {filename}: {e}")

# Example: Resize all images in a directory
def resize_operation(image, size):
    return image.resize(size, Image.Resampling.LANCZOS)

# Usage
# batch_process("input_images", "resized_images", resize_operation, (800, 600))
```

## 10. ADVANCED TECHNIQUES

### Image Sequences and Animation
```python
# Create a GIF animation
def create_animated_gif(images, output_filename, duration=100):
    """
    Create an animated GIF from a list of images
    
    Args:
        images: List of PIL Image objects or filenames
        output_filename: Output GIF filename
        duration: Frame duration in milliseconds
    """
    # Convert filenames to images if needed
    frames = []
    for img in images:
        if isinstance(img, str):
            frames.append(Image.open(img))
        else:
            frames.append(img)
    
    # Save as animated GIF
    frames[0].save(
        output_filename,
        save_all=True,
        append_images=frames[1:],
        optimize=True,
        duration=duration,
        loop=0  # 0 means loop forever
    )

# Example: Create a pulsing circle animation
def create_pulsing_circle():
    frames = []
    for radius in range(10, 100, 5) + range(100, 10, -5):
        frame = Image.new('RGB', (200, 200), (0, 0, 0))
        draw = ImageDraw.Draw(frame)
        draw.ellipse(
            [(100-radius, 100-radius), (100+radius, 100+radius)],
            fill=(int(255*(radius/100)), 64, 255-int(255*(radius/100)))
        )
        frames.append(frame)
    
    create_animated_gif(frames, "pulsing_circle.gif", 50)

# Example: Split frames from an animated GIF
def extract_gif_frames(gif_path, output_dir):
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)
        
    with Image.open(gif_path) as gif:
        for i in range(gif.n_frames):
            gif.seek(i)
            frame = gif.copy()
            frame.save(os.path.join(output_dir, f"frame_{i:03d}.png"))
```

### Working with Metadata
```python
from PIL import Image, ExifTags

def print_exif(image_path):
    """Print EXIF data for an image"""
    with Image.open(image_path) as img:
        # Check if image has EXIF data
        if hasattr(img, '_getexif') and img._getexif() is not None:
            exif_data = img._getexif()
            for tag_id, value in exif_data.items():
                # Get the tag name
                tag = ExifTags.TAGS.get(tag_id, tag_id)
                print(f"{tag}: {value}")
        else:
            print("No EXIF data found")

# Example: Preserve EXIF when processing
def preserve_exif_resize(input_path, output_path, size):
    """Resize an image while preserving EXIF data"""
    with Image.open(input_path) as img:
        # Store EXIF data
        exif_data = None
        if hasattr(img, '_getexif') and img._getexif() is not None:
            exif_dict = img._getexif()
            if exif_dict:
                exif_data = img.info.get('exif')
                
        # Process image
        resized = img.resize(size, Image.Resampling.LANCZOS)
        
        # Save with original EXIF
        if exif_data:
            resized.save(output_path, exif=exif_data)
        else:
            resized.save(output_path)
```

### Image Transformations
```python
from PIL import Image

# Perspective transformation
def perspective_transform(img, coeffs):
    """
    Apply perspective transformation
    
    Args:
        img: Source image
        coeffs: 8-tuple (x0,y0,x1,y1,x2,y2,x3,y3) containing
               the coordinates of the corners in the output image
    """
    width, height = img.size
    # The 4 corners of the source image
    src_corners = [(0, 0), (width-1, 0), (width-1, height-1), (0, height-1)]
    # Convert destination corners to format expected by transform method
    dest_corners = [coeffs[0:2], coeffs[2:4], coeffs[4:6], coeffs[6:8]]
    
    # Calculate transformation coefficients
    from PIL import Image
    transformed = img.transform(
        (width, height),
        Image.Transform.QUAD,
        data=sum(src_corners + dest_corners, ()),  # Flatten the coordinate lists
        resample=Image.Resampling.BICUBIC
    )
    
    return transformed

# Example: Apply perspective to make image look like a sign on a wall
coeffs = (20, 20, 280, 10, 300, 190, 10, 210)  # Destination corners
transformed = perspective_transform(img, coeffs)
transformed.save('perspective.jpg')
```

### Combining with OpenCV
```python
# Using PIL with OpenCV for advanced processing
import cv2
import numpy as np
from PIL import Image

def pil_to_opencv(pil_image):
    """Convert PIL Image to OpenCV format (numpy array)"""
    # Convert to RGB if needed (OpenCV uses BGR)
    if pil_image.mode != 'RGB':
        pil_image = pil_image.convert('RGB')
    # Convert to numpy array and change color channel order
    opencv_image = np.array(pil_image)
    # Convert RGB to BGR
    opencv_image = opencv_image[:, :, ::-1].copy()
    return opencv_image

def opencv_to_pil(opencv_image):
    """Convert OpenCV image to PIL Image"""
    # Convert BGR to RGB
    rgb_image = opencv_image[:, :, ::-1]
    # Convert to PIL Image
    pil_image = Image.fromarray(rgb_image)
    return pil_image

# Example: Use OpenCV for edge detection
def canny_edge_detection(pil_image, threshold1=100, threshold2=200):
    # Convert PIL to OpenCV
    cv_image = pil_to_opencv(pil_image)
    
    # Convert to grayscale
    gray = cv2.cvtColor(cv_image, cv2.COLOR_BGR2GRAY)
    
    # Apply Canny edge detection
    edges = cv2.Canny(gray, threshold1, threshold2)
    
    # Convert back to PIL (need to convert to RGB as Canny returns grayscale)
    result = Image.fromarray(edges).convert('RGB')
    return result

# Apply Canny edge detection
edges = canny_edge_detection(img)
edges.save('canny_edges.jpg')
```

## 11. ERROR HANDLING AND BEST PRACTICES

```python
def safe_image_open(file_path):
    """Safely open an image file with proper error handling"""
    try:
        img = Image.open(file_path)
        # Verify the image can be read
        img.verify()
        # Re-open because verify closes the file
        img = Image.open(file_path)
        return img
    except FileNotFoundError:
        print(f"File not found: {file_path}")
    except Image.DecompressionBombError:
        print(f"Image is too large and might cause memory issues: {file_path}")
    except Image.UnidentifiedImageError:
        print(f"Cannot identify image file: {file_path}")
    except Exception as e:
        print(f"Error opening image {file_path}: {e}")
    return None

# Memory-efficient processing for large images
def process_large_image(file_path, operation, tile_size=1024, output_path=None):
    """
    Process a large image in tiles to avoid memory issues
    
    Args:
        file_path: Path to image file
        operation: Function to apply to each tile
        tile_size: Size of square tiles to process
        output_path: Where to save the result (if None, uses original path)
    """
    if output_path is None:
        output_path = file_path
        
    # Open the image (but don't load it entirely into memory)
    with Image.open(file_path) as img:
        # Create output image with same size and mode
        result = Image.new(img.mode, img.size)
        
        # Process image in tiles
        for y in range(0, img.height, tile_size):
            for x in range(0, img.width, tile_size):
                # Calculate tile dimensions
                box = (x, y, min(x + tile_size, img.width), min(y + tile_size, img.height))
                # Get the tile
                tile = img.crop(box)
                # Process the tile
                processed_tile = operation(tile)
                # Paste it back
                result.paste(processed_tile, box)
                
        # Save result
        result.save(output_path)
        return result
```

## 12. PILLOW AND OTHER LIBRARIES

### Working with NumPy
```python
import numpy as np
from PIL import Image

# Convert PIL Image to NumPy array
img_array = np.array(img)
print(f"Array shape: {img_array.shape}, dtype: {img_array.dtype}")

# Manipulate with NumPy
# Example: Invert colors
inverted_array = 255 - img_array
inverted_img = Image.fromarray(inverted_array)
inverted_img.save('inverted.jpg')

# Example: Adjust brightness with NumPy
brightened_array = np.clip(img_array * 1.5, 0, 255).astype(np.uint8)
brightened_img = Image.fromarray(brightened_array)
brightened_img.save('numpy_brightened.jpg')

# Example: Split and merge channels
r_channel = img_array.copy()
r_channel[:, :, 1:3] = 0  # Zero out G and B channels
r_img = Image.fromarray(r_channel)
r_img.save('red_channel.jpg')
```

### Integration with matplotlib
```python
import matplotlib.pyplot as plt

def display_images(images, titles=None, figsize=(15, 10), cmaps=None):
    """
    Display multiple images in a grid
    
    Args:
        images: List of PIL Images or numpy arrays
        titles: List of titles for each image
        figsize: Figure size (width, height)
        cmaps: List of colormaps for each image (for grayscale images)
    """
    n = len(images)
    cols = min(3, n)
    rows = (n + cols - 1) // cols
    
    fig, axes = plt.subplots(rows, cols, figsize=figsize)
    if rows == 1 and cols == 1:
        axes = [axes]
    elif rows == 1 or cols == 1:
        axes = axes.flatten()
        
    for i, img in enumerate(images):
        if i < len(axes):
            # Convert PIL image to numpy if needed
            if isinstance(img, Image.Image):
                img = np.array(img)
                
            # Get cmap if provided
            cmap = None
            if cmaps and i < len(cmaps):
                cmap = cmaps[i]
            
            # Display image
            axes[i].imshow(img, cmap=cmap)
            axes[i].axis('off')
            
            # Add title if provided
            if titles and i < len(titles):
                axes[i].set_title(titles[i])
    
    # Hide unused subplots
    for i in range(len(images), len(axes)):
        fig.delaxes(axes[i])
    
    plt.tight_layout()
    plt.savefig('comparison.png')
    plt.show()

# Example: Compare different processing methods
original = img
grayscale = img.convert('L')
blurred = img.filter(ImageFilter.GaussianBlur(radius=5))
edge_enhanced = img.filter(ImageFilter.EDGE_ENHANCE_MORE)

# Convert grayscale to RGB for consistent display
grayscale_rgb = grayscale.convert('RGB')

display_images(
    [original, grayscale_rgb, blurred, edge_enhanced],
    titles=['Original', 'Grayscale', 'Blurred', 'Edge Enhanced'],
    figsize=(12, 8)
)
```

## 13. COMMON USE CASES AND RECIPES

### Create a Contact Sheet/Image Grid
```python
def create_contact_sheet(images, grid_size, thumbnail_size=(200, 200)):
    """
    Create a contact sheet from multiple images
    
    Args:
        images: List of PIL images or file paths
        grid_size: Tuple of (columns, rows)
        thumbnail_size: Size for each thumbnail
    
    Returns:
        PIL Image with the contact sheet
    """
    # Load images if file paths were provided
    loaded_images = []
    for img in images:
        if isinstance(img, str):
            loaded_images.append(Image.open(img))
        else:
            loaded_images.append(img)
    
    # Create thumbnails
    thumbnails = []
    for img in loaded_images:
        # Create a copy to avoid modifying original
        thumb = img.copy()
        thumb.thumbnail(thumbnail_size)
        thumbnails.append(thumb)
    
    # Create blank canvas
    cols, rows = grid_size
    sheet_width = thumbnail_size[0] * cols
    sheet_height = thumbnail_size[1] * rows
    contact_sheet = Image.new('RGB', (sheet_width, sheet_height), (255, 255, 255))
    
    # Paste thumbnails onto contact sheet
    for idx, thumb in enumerate(thumbnails):
        if idx >= cols * rows:
            break  # Stop if we've filled the grid
        
        # Calculate position
        row = idx // cols
        col = idx % cols
        x = col * thumbnail_size[0]
        y = row * thumbnail_size[1]
        
        # Center the thumbnail if smaller than thumbnail_size
        x_offset = (thumbnail_size[0] - thumb.width) // 2
        y_offset = (thumbnail_size[1] - thumb.height) // 2
        
        contact_sheet.paste(thumb, (x + x_offset, y + y_offset))
    
    return contact_sheet
```

### Add Borders and Frames
```python
def add_border(image, border_width=10, color=(255, 255, 255)):
    """Add a border around an image"""
    width, height = image.size
    new_width = width + 2 * border_width
    new_height = height + 2 * border_width
    
    bordered = Image.new(image.mode, (new_width, new_height), color)
    bordered.paste(image, (border_width, border_width))
    
    return bordered

def add_gradient_border(image, border_width=20, colors=[(255,0,0), (0,0,255)]):
    """Add a gradient border around an image"""
    from PIL import ImageDraw
    
    # Create new image with border
    width, height = image.size
    new_width = width + 2 * border_width
    new_height = height + 2 * border_width
    
    # Create blank image with first color
    result = Image.new('RGB', (new_width, new_height), colors[0])
    
    # Draw gradient (simplified - just horizontal gradient)
    draw = ImageDraw.Draw(result)
    for i in range(border_width):
        # Calculate color for this pixel based on position
        t = i / border_width
        r = int(colors[0][0] * (1 - t) + colors[1][0] * t)
        g = int(colors[0][1] * (1 - t) + colors[1][1] * t)
        b = int(colors[0][2] * (1 - t) + colors[1][2] * t)
        color = (r, g, b)
        
        # Draw top and bottom lines
        draw.line([(0, i), (new_width-1, i)], fill=color)
        draw.line([(0, new_height-i-1), (new_width-1, new_height-i-1)], fill=color)
        
        # Draw left and right lines
        draw.line([(i, 0), (i, new_height-1)], fill=color)
        draw.line([(new_width-i-1, 0), (new_width-i-1, new_height-1)], fill=color)
    
    # Paste original image
    result.paste(image, (border_width, border_width))
    return result

def add_photo_frame(image, frame_width=50, frame_color=(139, 69, 19)):
    """Add a photo frame with shadow effect"""
    width, height = image.size
    new_width = width + 2 * frame_width
    new_height = height + 2 * frame_width
    
    # Create the frame image
    framed = Image.new('RGB', (new_width, new_height), frame_color)
    
    # Create a drop shadow (black rectangle slightly offset)
    shadow = Image.new('RGBA', (width, height), (0, 0, 0, 180))
    framed.paste(shadow, (frame_width + 5, frame_width + 5), shadow)
    
    # Paste the original image
    framed.paste(image, (frame_width, frame_width))
    
    return framed
```

### Create a Watermark
```python
def add_text_watermark(image, text, position=None, color=(255, 255, 255, 128), font_size=40):
    """Add a text watermark to an image"""
    from PIL import ImageDraw, ImageFont
    
    # Create a transparent overlay
    overlay = Image.new('RGBA', image.size, (0, 0, 0, 0))
    draw = ImageDraw.Draw(overlay)
    
    try:
        font = ImageFont.truetype("arial.ttf", font_size)
    except IOError:
        font = ImageFont.load_default()
    
    # Calculate text size
    text_width = draw.textlength(text, font=font)
    
    # Set position (center by default)
    if position is None:
        position = ((image.width - text_width) // 2, image.height // 2)
    
    # Draw the text
    draw.text(position, text, font=font, fill=color)
    
    # Convert image to RGBA if it isn't already
    if image.mode != 'RGBA':
        image = image.convert('RGBA')
    
    # Composite the watermarked image
    watermarked = Image.alpha_composite(image, overlay)
    return watermarked

def add_image_watermark(image, watermark_image, position=None, opacity=0.3):
    """Add an image watermark to another image"""
    # Ensure the watermark has an alpha channel
    if watermark_image.mode != 'RGBA':
        watermark_image = watermark_image.convert('RGBA')
    
    # Create a copy of the watermark with desired opacity
    watermark = watermark_image.copy()
    alpha = watermark.split()[3]
    alpha = alpha.point(lambda x: int(x * opacity))
    watermark.putalpha(alpha)
    
    # Ensure base image has alpha channel
    if image.mode != 'RGBA':
        image = image.convert('RGBA')
    
    # Set position (center by default)
    if position is None:
        position = ((image.width - watermark.width) // 2, 
                   (image.height - watermark.height) // 2)
    
    # Create a new blank image with same size as original
    result = Image.new('RGBA', image.size, (0, 0, 0, 0))
    
    # Paste the original image
    result.paste(image, (0, 0))
    
    # Paste the watermark
    result.paste(watermark, position, watermark)
    
    return result
```

## 14. CONCLUSION

Pillow (PIL) is a powerful library for image processing in Python. It provides a wide range of functionality for working with images, from simple operations like resizing and cropping to more complex transformations and effects. This guide covers many common uses, but there's always more to explore in the official documentation.

Remember to consider performance and memory constraints when working with large images, and always handle errors appropriately to make your image processing applications robust.

For the latest information and updates, visit the official Pillow documentation: https://pillow.readthedocs.io/
```

I've created a comprehensive guide covering all major aspects of using PIL (Pillow) with numerous practical examples. The document includes basic operations, image manipulation techniques, color adjustments, filters, drawing capabilities, compositing, analysis tools, batch processing, and integration with other libraries.

Would you like me to expand on any particular section or add more examples for a specific functionality?